package main

import (
	"cobranca-bmp/cache"
	"cobranca-bmp/client"
	"cobranca-bmp/config"
	"cobranca-bmp/handlers"
	"cobranca-bmp/helpers"
	"cobranca-bmp/monitoring"
	"cobranca-bmp/queue"
	"cobranca-bmp/service"
	"context"
	"log"
	"log/slog"
	"os"
	"os/signal"
	"slices"
	"syscall"
	"time"

	"github.com/gofiber/fiber/v2"
	"github.com/gofiber/fiber/v2/middleware/adaptor"
	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promhttp"
)

// @title			BMP Cobrança
// @version		1.0
// @description	Microserviço de acesso aos serviços de geração de cobranças do BMP. \n Para mais informações referentes aos dados a serem enviados, consulte a aba "model" na seção de body dos endpoints.
// @contact.name	Felipe Augusto De Faria Freitas
// @contact.email	felipeaug92@gmail.com
// @host			bmp-fgts.Confiapay.com.br
// @BasePath		/
func main() {

	metricsRegister := prometheus.NewRegistry()

	dbPoolUtilizationPercent := prometheus.NewGaugeVec(prometheus.GaugeOpts{
		Name: "bmp_pool_usage",
		Help: "Usage of db pool",
	}, []string{})

	dbPoolIddlePercent := prometheus.NewGaugeVec(prometheus.GaugeOpts{
		Name: "bmp_pool_usage_iddle",
		Help: "Usage of db iddle connection",
	}, []string{})

	alertsMetric := prometheus.NewHistogramVec(prometheus.HistogramOpts{
		Name: "bmp_db_alert",
		Help: "Alerts generated by dbpol",
	}, []string{"type"})

	metricsRegister.MustRegister(dbPoolUtilizationPercent)
	metricsRegister.MustRegister(dbPoolIddlePercent)
	metricsRegister.MustRegister(alertsMetric)
	//metricsRegister.MustRegister(helpers.LogMetrics)

	prometheusHandler := promhttp.HandlerFor(metricsRegister, promhttp.HandlerOpts{})

	sig := make(chan os.Signal, 1)
	signal.Notify(sig, syscall.SIGINT, syscall.SIGTERM)
	ctx, cancel := context.WithCancel(context.Background())

	var files = []string{}

	//Configurações de teste local
	if !slices.Contains(os.Args, "nonlocal") {
		config.HOMOLOG_LOCAL = true
		files = append(files, ".homolog.env")

	}

	//Carregando variáveis de ambiente
	err := config.LoadEnvVar(files...)
	if err != nil {
		log.Fatalf("erro ao carregar variaveis de ambiente: %s", err.Error())
	}

	//Configurando o fuso horário(será utilizado para gravar corretamente a data no banco de dados)
	loc, err := time.LoadLocation("America/Sao_Paulo")
	if err != nil {
		log.Fatal("Erro ao carregar fuso horário para America/Sao_Paulo", err)
	}

	//Instanciando loggers
	rmqLogger := slog.New(helpers.NewECSJSONHandler(slog.LevelInfo, loc))
	//dbLogger := slog.New(helpers.NewECSJSONHandler(slog.LevelInfo, loc))
	redisLogger := slog.New(helpers.NewECSJSONHandler(slog.LevelInfo, loc))
	clientLogger := slog.New(helpers.NewECSJSONHandler(slog.LevelInfo, loc))
	elegibilidadeServiceLogger := slog.New(helpers.NewECSJSONHandler(slog.LevelInfo, loc))
	webhookLogger := slog.New(helpers.NewECSJSONHandler(slog.LevelDebug, loc))
	//logFileLogger := slog.New(helpers.NewECSJSONHandler(slog.LevelInfo, loc))
	fiberLogger := slog.New(helpers.NewECSJSONHandler(slog.LevelInfo, loc))
	slog.SetDefault(slog.New(helpers.NewECSJSONHandler(slog.LevelInfo, loc)))

	defer func() {
		cancel()
		helpers.LogInfo(ctx, slog.Default(), loc, "main", "", "Programa encerrado", nil)
	}()

	//Se conectando ao banco de dados
	//	database, err := db.Open(config.DB_URL)
	//if err != nil {
	//	log.Fatalf("Erro ao se conectar com o banco de dados: %s", err.Error())
	//}

	/*
		//Instanciando um objeto que gerenciará o banco de dados e o injetará nos repositórios em caso de reconexão.
		dbManager := db.NewDBManager(ctx, database, "postgres_Confiapay", loc, dbLogger, config.NewDBPoolConfigFromEnv(),
			propostaCreditoPessoalRepo)

		var prometheusDbCollectors = monitoring.PrometheusCollectors{
			UtilizationPercent: dbPoolUtilizationPercent,
			IddlePercent:       dbPoolIddlePercent,
			AlertNum:           alertsMetric,
		}

		//Instanciando e startando um monitor de conexões do banco de dados.
		poolMonitor := monitoring.NewPoolMonitor(dbManager, loc, dbLogger, &prometheusDbCollectors)
		go poolMonitor.Start(ctx, config.DB_POOL_MONITORING_INTERVAL)

		//shutdown do banco de dados
		defer dbManager.Close()

		//Instanciando um serviço de atualização de propostas
		updateCreditoPessoalService := service.NewUpdateService(propostaCreditoPessoalRepo, dbLogger, loc, config.CREDITO_PESSOAL_CONVENIO)

		//Instanciando um handler de arquivos
		fileLoggerChan := make(chan models.DbLogfileData)
		logFileHandler := logfile.NewLogFileHandler(ctx, logFileLogger, fileLoggerChan, loc, updateCreditoPessoalService)

		//go logFileHandler.Consume()
		//defer logFileHandler.Close()*/

	//Configurando e startando o redis
	redis, err := cache.NewRedis(config.REDIS_URL, redisLogger, ctx, loc, nil, config.REDIS_DBCH, nil)
	if err != nil {
		log.Fatalf("Erro ao se conectar ao Redis: %s", err.Error())
	}
	/*if err := redis.SetSubscriber(); err != nil {
		log.Fatalf("Erro ao setar subscriber no Redis: %s", err.Error())

	}

	go redis.Consume()*/
	defer redis.Close()

	//Instanciando serviços de webhook
	webhookClient := client.NewWebhookClient(ctx, loc, clientLogger)
	webhookService := service.NewWebhookService(webhookClient, loc)

	//Instanciando clients que serão utilizado pelos services que precisam chamar a API do BMP.
	cobrancaClient := client.NewCobrancaClient(ctx, loc, redis, clientLogger, config.BASE_URL, config.AUTH_URL)

	//Instanciando serviços de cobrança
	cobrancaService := service.NewCobrancaService(ctx, elegibilidadeServiceLogger, loc, cobrancaClient, webhookService, redis)

	rmq, err := queue.NewRMQ(
		ctx, loc, redis, rmqLogger,
		webhookService, cobrancaService,
		config.RABBITMQ_QOS)

	if err != nil {
		log.Fatalf("erro ao se conectar com as filas: %s", err.Error())
	}

	//Cada fila será consumida em uma goroutine diferente e nonitore server monitorará a conexão com o RabbitMQ.

	go rmq.ConsumeQueues()
	defer rmq.Close()

	//Instanciando os controllers
	healthChecker := monitoring.NewServicesHealthChecker(rmq, redis)
	cobrancaController := handlers.NewCobrancaCreditoPessoalController(redis, cobrancaService, webhookService, loc)
	configController := handlers.NewConfigController(rmq, nil, nil)
	monitoringControllers := handlers.NewMonitoringController(loc, nil, nil, healthChecker, redis, rmq)

	//Configurando o app do Fiber e suas rotas
	app := fiber.New(fiber.Config{EnablePrintRoutes: true,
		EnableTrustedProxyCheck: false,
	})
	config.ConfigRoutes(app, fiberLogger,
		configController,
		cobrancaController, monitoringControllers)

	app.Get("/metrics", adaptor.HTTPHandler(prometheusHandler))
	//Executando o app em uma goroutine separada
	go func() {
		err := app.Listen(":8080")
		if err != nil {
			log.Fatalf("Erro ao inicializar app do Fiber: %s", err.Error())
		}
	}()
	//shutdown do app
	defer func() {
		err := app.Shutdown()
		if err != nil {
			helpers.LogError(ctx, webhookLogger, loc, "fiber", "", "Erro ao realizar shutdown de servidor", err, nil)
			return
		}
		helpers.LogInfo(ctx, webhookLogger, loc, "fiber", "", "Shutdown de servidor realizado com sucesso", nil)
	}()

	<-sig

}
